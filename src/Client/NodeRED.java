package Client;



public class NodeRED extends Node {
	int rand; // random value generated by Hypervisor
	
	
	NodeRED( int id, Position pos, int en, int r){
		super( id, pos, en );
		rand=r;
	}
	
	
	public void receiveMessageClaim( MessageClaim msg ) throws ExcEndEnergy, ExcFindClone {
		// con probabilità 1-p non gestisco il messaggio e termino, mentre con prob p lo accetto
		
		if( (float)Math.random() <= 1-probAcceptLocation )  return; // ignora il messaggio
		
		checkEnergy(energyToReceive);
		
		receivedMessages++;
		
		NodeRED receiver =  null;
		
		// g time
		for(int i=0; i< locationDestination; i++){
			
			Position pos = hashPosition( msg.getIdSender(), rand, i );
			MessageControl mc = new MessageControl( (MessageClaim)msg, pos);
			
			// buffer neighbors isn't empty
			receiver = (NodeRED)nearestNeighbor(pos);
			
			// se il + vicino alla destinazione del messagControll creato è il nodo stesso, faccio la detection
			if( receiver == this){
				if( findClone(mc) ){ 
					//if( isInterrupted() ) throw new SecurityException();
					checkEndSimulazion();
					//synchronized( lockEndSim ){ if( endSimulation ) throw new SecurityException(); }
					Node.detection=1; throw new ExcFindClone();
				} 
				Node.detection=1;
				memoryMsg.add(mc);
			}
			else{
				// invio il messaggio di controllo al neighbor + vicino alla destinazione p del messaggio,
				//if( isInterrupted() ) throw new SecurityException();
				checkEndSimulazion();
				//synchronized( lockEndSim ){ if( endSimulation ) throw new SecurityException(); }
				checkEnergy(energyToSend);
				sentMessages++;
				sendMessageControl( receiver, mc );
			}
		}

	}

	
	public void receiveMessageControl( MessageControl msg ) throws ExcEndEnergy, ExcFindClone, SecurityException{
		//if( isInterrupted() ) throw new SecurityException();
		checkEndSimulazion();
		//synchronized( lockEndSim ){ if( endSimulation ) throw new SecurityException(); }
		checkEnergy(energyToReceive);
		
		receivedMessages++;
				
		Node receiver= nearestNeighbor( msg.getPosReceiver());

		// if the receiver of the message is the node itself
		if( this == receiver ){
			if( findClone(msg) ){
				//if( isInterrupted() ) throw new SecurityException();
				checkEndSimulazion();
				//synchronized( lockEndSim ){ if( endSimulation ) throw new SecurityException(); }
				Node.detection=1; throw new ExcFindClone();
			}
			Node.detection=1;
		
			memoryMsg.add(msg);
			return;
		}
		
		//if( isInterrupted() ) throw new SecurityException();
		checkEndSimulazion();
		//synchronized( lockEndSim ){ if( endSimulation ) throw new SecurityException(); }
		checkEnergy(energyToSend);
		sentMessages++;
		sendMessageControl( receiver, msg);
	}
	
	
	public boolean findClone( MessageControl msg ){
		if( msg.getIdSender() == id && msg.getPosSender()!= pos )
			return true;
		
		return false;
	}
	
	// hash function to generate the position destination of message control 
	static public Position hashPosition( int id, int rand, int counter){
		String stringToHashX=new String( Integer.toString(id+rand+counter));
		String stringToHashY=new String( Integer.toString(counter+rand+id));
		
		float doubleForX=stringToHashX.hashCode();
		float doubleForY=stringToHashY.hashCode();
		
		Float normalizedDoubleForX=normalize(doubleForX);
		Float normalizedDoubleForY=normalize(doubleForY);

		return new Position(normalizedDoubleForX,normalizedDoubleForY);

	}

	// function to normalize number ( e.g. 34566 => 0.34566 )
	private static float normalize(float toNormalize){
		toNormalize=Math.abs(toNormalize);
		float index=1;
		while (index<toNormalize){
			index=index*10;
		}
		return toNormalize/index;
	}

	
}



